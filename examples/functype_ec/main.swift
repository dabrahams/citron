import CitronParserModule
import CitronLexerModule

enum Token {
    case keyword // for func, throws, inout, etc.
    case punctuation // for (, ), ->, etc.
    case identifier(String) // for identifiers
    func toIdentifierString() -> String? {
        if case .identifier(let id) = self {
            return id
        }
        return nil
    }
}

struct FunctionParameter {
    let localName: String
    let externalName: String?
    let type: String
    let isInout: Bool
}

struct FunctionHeader {
    enum Throwability {
        case throwing
        case rethrowing
        case nonthrowing
    }
    let name: String?
    let parameters: [FunctionParameter?]?
    let returnType: String
    let throwability: Throwability

    func typeString() -> String {
        return "("
                + (parameters ?? []).map { p in
                    p == nil ? "ERROR" :
                      (p!.isInout ? "inout \(p!.type)" : p!.type)
                    }.joined(separator: ", ")
                + (throwability == .nonthrowing ? ") -> " : ") throws -> ")
                + returnType
    }
}

typealias Lexer = CitronLexer<(token: Token, code: FunctionHeaderParser.CitronTokenCode)>

func parseFunctionHeader(input: String) -> FunctionHeader? {

    // Create parser
    let parser = FunctionHeaderParser()

    // Create lexer
    let lexer = Lexer(rules: [

            // Keywords

            .string("func", (.keyword, .funcHeaderKeywordFunc)),
            .string("throws", (.keyword, .funcHeaderKeywordThrows)),
            .string("rethrows", (.keyword, .funcHeaderKeywordRethrows)),
            .string("inout", (.keyword, .funcHeaderKeywordInout)),

            // Punctuations

            .string("->", (.punctuation, .funcHeaderArrow)),
            .string("(", (.punctuation, .funcHeaderOpenBracket)),
            .string(")", (.punctuation, .funcHeaderCloseBracket)),
            .string(",", (.punctuation, .funcHeaderComma)),
            .string(":", (.punctuation, .funcHeaderColon)),

            // Identifiers

            .regexPattern("[a-zA-Z0-9_]+", { str in
                (.identifier(str), .funcHeaderIdentifier)
            }),

            // Ignore whitespace

            .regexPattern("\\s", { _ in nil })
        ])

    // Enable error capturing
    let errorReporter = ErrorReporter(input: input)
    parser.errorCaptureDelegate = errorReporter

    // Tokenize and parse
    var funcHeader: FunctionHeader? = nil
    do {
        try lexer.tokenize(input,
            onFound: { t in
                try parser.consume(token: (token: t.token, position: lexer.currentPosition), code: t.code)
            },
            onError: { (e) in
                try parser.consume(lexerError: e)
            })
        errorReporter.endOfInputPosition = lexer.currentPosition
        funcHeader = try parser.endParsing()
    } catch CitronLexerError.noMatchingRuleAt(let pos) {
        print("Error during tokenization after '\(input.prefix(upTo: pos.tokenPosition))'.")
    } catch (let e as FunctionHeaderParser.UnexpectedTokenError) {
       print("Error during parsing: Unexpected token: \(e.tokenCode) (\(e.token))")
    } catch (is FunctionHeaderParser.UnexpectedEndOfInputError) {
        print("Error during parsing: Unexpected end of input")
    } catch (let error) {
        print("Error during parsing: \(error)")
    }
    if (parser.numberOfCapturedErrors > 0) {
        return nil
    }
    return funcHeader
}

if CommandLine.argc != 2 {
    print("Pass the function header to be parsed as a quoted argument.")
} else {
    if let funcHeader = parseFunctionHeader(input: CommandLine.arguments[1]) {
       print("Function type is: \(funcHeader.typeString())")
    }
}
